# FooBar

## Overview
This project is a basic .NET 8 web API application demonstrating a clean architecture with a Model-Repository-Service-Controller structure. It uses Entity Framework Core to interact with an MSSQL database running in a Docker container.

## Project Structure
- Model: Defines the data structure.
- Repository: Handles data access logic.
- Service: Contains business logic and calls repository methods.
- Controller: Manages HTTP requests and responses, using the service to perform operations.

---

## Key Directories and Files

### Directories

#### Controllers 
- Contains API controllers that handle HTTP requests.

#### Data
- Contains the AppDbContext class for Entity Framework Core configuration.

#### Migrations
- Contains database migrations generated by Entity Framework Core.

#### Models
- Contains entity classes representing the data structure.

#### Properties
- Contains configuration files related to project properties.

#### Repositories
- Contains repository interfaces and implementations for data access.

#### Services
- Contains service interfaces and implementations for business logic.

### Files

#### appsettings.json / appsettings.Development.json:
- Configuration file for application settings.
    - database connection strings

#### docker-compose.yml
- docker-compose for starting local db

#### Program.cs
- The `Program.cs` file is the entry point to a .NET application. It contains the Main method, which is the starting point of the application. In modern .NET applications using .NET Core and .NET versions > 5.
- Program.cs is used to set up and configure the application, including services, middleware, and the HTTP request pipeline.
- I's a convention to use `Program.cs` as the name but the name can be changed by adding `<StartupObject>FooBar.ApplicationEntrypoint</StartupObject>` to `FooBar.csproj` replacing `ApplicationEntrypoint` with whatever you renamed `Program.c`s to.

#### FooBar.csproj
Similar to package.json in node or pom.xml in java projects.
1. Project Configuration: Specifies the target framework, output type, and other project settings.
2. Dependencies: Lists NuGet packages and project references required by the project.
3. Build Settings: Defines how the project should be built, including compiler options and build tasks.
4. Versioning: Specifies the version of the application or library.
5. Metadata: Contains metadata such as project name, description, authors, and company information.

---

## Getting Started
### Prerequisites
Ensure you have the following installed on your Mac:

- [Homebrew](https://brew.sh/)
- [.NET SDK](https://dotnet.microsoft.com/en-us/download): `brew install --cask dotnet-sdk`
- [Docker](https://docs.docker.com/get-docker/): `brew install --cask docker`
- [Terraform](https://www.terraform.io/): `brew install terraform`

### Setup DB Driver
    [microsoft-odbc-18](https://learn.microsoft.com/en-us/sql/connect/odbc/linux-mac/install-microsoft-odbc-driver-sql-server-macos?view=sql-server-ver16#microsoft-odbc-18)

1. `brew tap microsoft/mssql-release https://github.com/Microsoft/homebrew-mssql-release`
2. `brew update`
3. `HOMEBREW_ACCEPT_EULA=Y brew install msodbcsql18 mssql-tools18`
4. `touch ~/.odbc.ini`
Add the following to `~/.odbc.ini`
    ```
    [MSSQLDocker]
    Description = MSSQL Server in Docker
    Driver = ODBC Driver 18 for SQL Server
    Server = localhost,1433
    Database = master
    User = sa
    Password = YourStrong!Passw0rd
    TrustServerCertificate = Yes
    ```

### Apple Silicon M1, M2, M3 Mac extra step (ignore if you have an older Mac)
- Once Docker Desktop is running, open the Dashboard and go into Settings (Cog at the top right)
- Open the “Features in development” menu item, and select the “Use Rosetta for x86/amd64 emulation on Apple Silicon” checkbox
- Restart Docker
- <b>Can potentially avoid doing the above by setting this as an env variable: `export DOCKER_DEFAULT_PLATFORM=linux/amd64`</b>

### Test DB Connection (After starting container)
- `isql MSSQLDocker sa 'YourStrong!Passw0rd'`
- Run query from terminal: `sqlcmd -S localhost,1433 -U sa -P 'YourStrong!Passw0rd' -d master -C -W -s '|' -Q "SELECT * FROM Users;"`
- `bcp master.INFORMATION_SCHEMA.TABLES out OutFile.dat -S "localhost,1433;TrustServerCertificate=yes" -U sa -P 'YourStrong!Passw0rd' -c`


### Setup
1. Start the MSSQL container
    - `docker compose up -d`
2. Install entity framework
    - `dotnet tool install --global dotnet-ef`
3. Generate and apply initial migrations
    - `dotnet ef database update`
4. Run the app:
    - `dotnet run` or `dotnet run --environment Azure` or `dotnet run --environment Development`

## Docker Commands
- `docker compose down`
- `docker compose up -d`


## dotnet CLI Commands
- `dotnet ef migrations add InitialCreate`  
- `dotnet run`
- Run using development settings: `dotnet run --environment Development`
- Run using db in Azure: `dotnet run --environment Azure`
- `dotnet ef migrations add AddUserTable`
- `dotnet ef database update`

## DB
### SQL Editor
[azure data studio](https://learn.microsoft.com/en-us/azure-data-studio/)
`brew install --cask azure-data-studio`

### Connection info
    - within appsettings.json: `"DefaultConnection": "Server=localhost,1433;Database=master;User Id=sa;Password=YourStrong!Passw0rd;Encrypt=false;TrustServerCertificate=true;"`
    - within dadbod-ui: `:DB sqlserver://sa:YourStrong!Passw0rd@localhost:1433?database=master&TrustServerCertificate=true`

## Swagger UI URL
http://localhost:5056/swagger/index.html

## Entity Framework
Model: 
- Defines the data structure. It's a blueprint.

Entity: 
- An instance of a model. It represents actual data loaded from the database.

Entity Framework: 
- Manages the mapping between the model classes and the database, handles CRUD operations, and tracks changes to entity objects.

`dotnet ef migrations add AddUserTable`
This command is used to create a new migration file that represents changes to your Entity Framework Core model. When you run this command, Entity Framework Core inspects the current state of your DbContext and compares it to the previous migration (or initial state if no migrations exist). It then generates a new migration file (AddUserTable in this case) containing the necessary code to update the database schema to reflect the changes in your model.

- What Happens:
    - Model Snapshot: Entity Framework Core maintains a model snapshot (in the migrations folder) that keeps track of the current state of your DbContext and its associated models.
    - Diff Analysis: When you run dotnet ef migrations add, EF Core analyzes any differences between the current state of the DbContext and the previous migration.
    - Migration File Generation: EF Core generates a new migration file (AddUserTable) in the migrations folder. This file contains:
    - Instructions to create or alter tables (Up method).
    - Instructions to revert the changes (Down method) if needed (for rollback scenarios).

`dotnet ef database update`
This command applies the migrations to the database. It executes the Up methods of any pending migrations that have not been applied to the target database.

- What Happens:
    - Database Connection: EF Core uses the connection string (DefaultConnection in your case) defined in your DbContext configuration to connect to the target database.
    - Migrations Application: It applies any pending migrations (those not already applied to the database). This involves:
    - Executing the SQL commands generated in the Up methods of each migration file.
    - Updating the __EFMigrationsHistory table in the database to track which migrations have been applied.

## Azure

### Setup
- `brew install azure-cli`
- `terraform init`
- `terraform apply`

### Login:
`az login`

### Create Infra in Azure
#### Connection String settings
Server=tcp:fooBarSqlServer.database.windows.net,1433;Initial Catalog=fooBarDatabase;Persist Security Info=False;User ID=fooBarAdmin;Password=YourStrong!Passw0rd;MultipleActiveResultSets=False;Encrypt=True;TrustServerCertificate=False;Connection Timeout=30;
1. Spin up Resources with Terraform
   - `terraform init`
   - `terraform apply`
   
2. Create and Apply Migrations: 
  - `dotnet ef database update`

3. Update ODBC settings:
   - `Driver={ Driver 18 for SQL Server};Server=tcp:foobarsqlserver.database.windows.net,1433;Database=foobardatabase;Uid=foobaradmin;Pwd={YourStrong!Passw0rd};Encrypt=yes;TrustServerCertificate=no;Connection Timeout=30;`

4. Publish new Docker version
   - publish to dockerhub
   ```# log in to dockerhub
        docker login

        # build image
        docker build -t kaiftait/foobar:latest .

        # push image
        docker push kaiftait/foobar:latest
   ```

   - ```# Log in to Azure Container Registry
        az acr login --name foobarcontainerregistry

        # Build the Docker image
        docker build -t foobarcontainerregistry.azurecr.io/foobar:latest .

        # Push the Docker image to Azure Container Registry
        docker push foobarcontainerregistry.azurecr.io/foobar:latest```
5. Mark resources for recreation in terraform
   - `terraform taint azurerm_container_group.foobar`

6. Apply changes
   - `terraform apply`
   
7. Get App IP
   - `az container show --resource-group foobar-resource-group --name foobarcontainergroup --query ipAddress.ip --output tsv`
